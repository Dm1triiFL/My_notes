---
tags:
  - Java
---

> [!NOTE]
> ### Определение
> **Consumer** в Java — это функциональный интерфейс, который представляет операцию, принимающую один аргумент и не возвращающую результата. Он обычно используется для обработки данных, например, для выполнения действий, которые не требуют возвращения значения.

### Основные Характеристики
- **Одно входное значение:** Consumer принимает один аргумент определенного типа.
- **Отсутствие возвращаемого значения:** Метод `accept(T t)` не возвращает никакого значения.

### Пример Использования

Рассмотрим сценарий, где мы хотим вывести на экран текстовое сообщение. Вот как это можно сделать с использованием интерфейса Consumer:

```java
import java.util.function.Consumer;

public class ConsumerExample {
    public static void main(String[] args) {
        // Создание Consumer, который выводит строку на экран
        Consumer<String> printMessage = message -> System.out.println(message);

        // Использование Consumer
        printMessage.accept("Привет, мир!"); // Вывод: Привет, мир!
    }
}
```

### Когда Использовать Consumer
- **Обработка данных:** Когда вам нужно выполнить действие над данными (например, сохранить, вывести, изменить), но без необходимости возвращать новое значение.
- **Подписчики:** Может использоваться в инфраструктуре реактивного программирования для обработки событий.

### Методы для Комбинации
Интерфейс Consumer также предоставляет методы для комбинирования:

- **andThen:** Позволяет связывать несколько операций в последовательность:
  ```java
  Consumer<String> upperCaseConsumer = message -> System.out.println(message.toUpperCase());
  Consumer<String> combinedConsumer = printMessage.andThen(upperCaseConsumer);
  combinedConsumer.accept("Привет!"); // Сначала выведет "Привет!", затем "ПРИВЕТ!"
  ```

### Заключение
Интерфейс Consumer в Java является полезным инструментом для выполнения действий над входными данными без необходимости возвращать значения. Его простота и возможность комбинирования делают его подходящим для множества задач в функциональном программировании.